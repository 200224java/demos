DROP TABLE employees CASCADE CONSTRAINTS;
CREATE TABLE employees (
	employee_id NUMBER(38) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
	first_name VARCHAR2(50) NOT NULL CHECK (LENGTH(first_name) > 1),
 	last_name VARCHAR2(50) NOT NULL,
	email VARCHAR2(55) UNIQUE,
	salary NUMBER NOT NULL,
	title VARCHAR2(55)
);

INSERT INTO employees (first_name, last_name, salary, title)
  VALUES ('John', 'Smith', 50000, 'Employee');
INSERT INTO employees (first_name, last_name, email, salary, title)
  VALUES ('Jane', 'Doe', 'jane.doe@gmail.com', 150000, 'Administrator');
INSERT INTO employees (first_name, last_name, email, salary, title)
  VALUES ('Larry', 'Niven', 'larry.niven@gmail.com', 200000, 'Employee');
INSERT INTO employees (first_name, last_name, email, salary, title)
  VALUES ('Craig', 'Jones', 'craig.jones@work.com', 126000, 'Administrator');
SELECT * FROM employees;

SELECT * FROM employees WHERE salary > 100000;

SELECT * FROM employees WHERE LENGTH(last_name) > 3;
-- The WHERE clause allows us to filter our results based on some condition
-- We can additionally apply scalar functions with this clause
-- Single line comment

/*
This is a multi-line comment
*/


/*
There are scalar and aggregate functions in SQL

Scalar functions provide an output for each input
Ex:
LOWER()
UPPER()
ABS()
COS(), SIN(), TAN()
ROUND() <-- To the nearest whole number
LOG()
CONCAT()
LENGTH()
TRIM() <-- Eliminates white space
LTRIM() & RTRIM() <-- TRIM on only one side

Aggregate functions produce only 1 output for any number of inputs
In general, we will apply aggregate functions to entire columns, and
receive just a single result
Ex:
SUM()
AVG()
MIN() & MAX()
STDDEV() & VARIANCE()
COUNT()
FIRST() & LAST()
*/


SELECT COUNT(*) FROM EMPLOYEES;

SELECT SUM(salary) FROM employees;

SELECT title, AVG(salary) FROM employees
	GROUP BY title
	ORDER BY AVG(salary) DESC; -- ascending BY DEFAULT

SELECT title, AVG(salary) FROM employees
	WHERE LENGTH(last_name) > 3
	GROUP BY title
	HAVING AVG(salary) > 125000
	ORDER BY AVG(salary) DESC;

/*

ORDER OF OPERATIONS:

1) FROM
2) WHERE
3) GROUP BY
4) HAVING
5) SELECT -- Defining which columns are being retrieved
6) ORDER BY
*/

/*
LIKE keyword allows us to filter text based on wildcards

The % wildcard is a placeholder for any number of characters (0+)
The _ wildcard is a placeholder for exactly 1 character

These can be used as many times as you want
*/

SELECT * FROM employees
	WHERE UPPER(first_name) LIKE '%Y%'
	AND UPPER(first_name) LIKE '%A%';

DROP TABLE account CASCADE CONSTRAINTS;
CREATE TABLE account (
	id NUMBER(38) GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
	balance NUMBER(38, 2) DEFAULT 0
);

DROP TABLE ACCOUNT_EMPLOYEE_JT CASCADE CONSTRAINTS;
CREATE TABLE account_employee_jt (
	account_id REFERENCES account (id),
	employee_id REFERENCES employees (employee_id),
	
	PRIMARY KEY (account_id, employee_id)
);

INSERT INTO account (id) VALUES (NULL);
INSERT INTO account (id) VALUES (NULL);

INSERT INTO ACCOUNT_EMPLOYEE_JT VALUES (1, 2); -- Jane owns first account
INSERT INTO ACCOUNT_EMPLOYEE_JT VALUES (2, 2); -- Jane owns second account
INSERT INTO ACCOUNT_EMPLOYEE_JT VALUES (1, 1); -- John also owns first account

/*
	Our goal here is to JOIN the account and employees tables
	through our join-table in order to display
	a single query result
	with all of the employee information side by side with
	the account information
	If an employee owns multiple accounts, then they appear as multiple
	records
	
	We accomplish this with SQL JOIN operations
*/

SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, e.EMAIL,
	   e.SALARY, e.TITLE, account.ID, account.BALANCE FROM
	   employees e FULL OUTER JOIN ACCOUNT_EMPLOYEE_JT aej
	   ON e.employee_id = aej.employee_id
	FULL OUTER JOIN account ON aej.ACCOUNT_ID = account.ID;

/*SELECT * FROM employees e FULL OUTER JOIN ACCOUNT_EMPLOYEE_JT aej
	ON e.EMPLOYEE_ID = aej.EMPLOYEE_ID;*/
DROP VIEW TEMPQUERY;
CREATE VIEW tempquery AS
	SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, e.EMAIL,
	   e.SALARY, e.TITLE, account.ID, account.BALANCE
	   FROM employees e FULL OUTER JOIN ACCOUNT_EMPLOYEE_JT aej
	   ON e.employee_id = aej.employee_id
	FULL OUTER JOIN account ON aej.ACCOUNT_ID = account.ID;
	
SELECT * FROM tempquery;

DROP TABLE LEFT;
CREATE TABLE LEFT (
	value NUMBER PRIMARY KEY
);

DROP TABLE RIGHT;
CREATE TABLE RIGHT (
	value NUMBER PRIMARY KEY
);

INSERT INTO LEFT VALUES (1);
INSERT INTO LEFT VALUES (2);
INSERT INTO LEFT VALUES (3);

INSERT INTO RIGHT VALUES (4);
INSERT INTO RIGHT VALUES (5);
INSERT INTO RIGHT VALUES (6);

SELECT * FROM LEFT CROSS JOIN RIGHT CROSS JOIN RIGHT CROSS JOIN RIGHT;

SELECT * FROM (
	SELECT * FROM (
		SELECT * FROM employees
		ORDER BY SALARY DESC, EMPLOYEE_ID ASC)
	WHERE ROWNUM <= 4
	ORDER BY SALARY ASC)
FETCH NEXT 75 PERCENT ROWS ONLY;

SELECT * FROM EMPLOYEES e WHERE e.SALARY BETWEEN 150000 AND 200000;
-- The BETWEEN clause allows us to select a range of values
-- It is inclusive on both ends

SELECT * FROM LEFT WHERE value IN (3, 4, 5);
-- The IN clause allows us TO specify a DISTINCT SET OF VALUES
-- that a COLUMN value must be IN

SELECT * FROM TEMPQUERY t;

/*SELECT count(EMPLOYEE_ID) FROM EMPLOYEES e
	GROUP BY EMPLOYEE_ID
	HAVING count(EMPLOYEE_ID) > 1;*/
-- The above STATEMENT ONLY IS useful IF you do
-- NOT have a PRIMARY KEY, it finds duplicate ids

COMMIT;
SELECT * FROM EMPLOYEES e;
UPDATE EMPLOYEES
	SET LAST_NAME = 'Doe'
	WHERE EMPLOYEE_ID = 1;
COMMIT;

/*
 * There are several SET operations:
 * UNION & UNION ALL
 * INTERSECT
 * MINUS
 * 
 * Refer to the venn diagrams for how they work
 * 
 * Note:
 * SET operations only work on tables that have a matching
 * number AND type of columns
 */



INSERT INTO LEFT VALUES (4);

SELECT * FROM LEFT
UNION
SELECT * FROM RIGHT;
-- UNION has NO duplicates

SELECT * FROM LEFT
UNION ALL
SELECT * FROM RIGHT;
-- UNION ALL DOES have duplicates

SELECT * FROM LEFT
INTERSECT
SELECT * FROM RIGHT;

SELECT * FROM LEFT
MINUS
SELECT * FROM RIGHT;

SELECT * FROM LEFT
UNION
SELECT * FROM RIGHT MINUS
(SELECT * FROM LEFT
INTERSECT
SELECT * FROM RIGHT);

COMMIT;